<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XFire - Skirmish RTS</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Arial, sans-serif;
            color: #eee;
        }

        /* Main Menu */
        #mainMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #1a1a2e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        #mainMenu.hidden { display: none; }
        #mainMenu h1 {
            font-size: 72px;
            color: #ff6b35;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.5), 0 0 40px rgba(255,107,53,0.3);
            margin-bottom: 10px;
            letter-spacing: 8px;
        }
        #mainMenu .subtitle {
            color: #888;
            font-size: 18px;
            margin-bottom: 40px;
        }
        .menu-panel {
            background: rgba(30, 30, 48, 0.95);
            border: 2px solid #333;
            border-radius: 8px;
            padding: 30px;
            min-width: 400px;
        }
        .menu-panel h2 {
            color: #ff6b35;
            font-size: 18px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
        }
        .setting-row label {
            color: #ccc;
        }
        .setting-row select, .setting-row input {
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            min-width: 150px;
        }
        .setting-row select:focus, .setting-row input:focus {
            outline: none;
            border-color: #ff6b35;
        }
        #startBtn {
            width: 100%;
            padding: 15px;
            margin-top: 20px;
            background: linear-gradient(180deg, #ff6b35 0%, #e55a25 100%);
            border: none;
            border-radius: 4px;
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
        }
        #startBtn:hover {
            background: linear-gradient(180deg, #ff8855 0%, #ff6b35 100%);
            transform: scale(1.02);
        }

        /* Game Over Overlay */
        #gameOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 999;
        }
        #gameOverlay.hidden { display: none; }
        #gameOverlay h1 {
            font-size: 64px;
            margin-bottom: 20px;
            text-shadow: 0 0 30px currentColor;
        }
        #gameOverlay.victory h1 { color: #4f4; }
        #gameOverlay.defeat h1 { color: #f44; }
        #gameOverlay p {
            font-size: 24px;
            color: #aaa;
            margin-bottom: 30px;
        }
        #gameOverlay button {
            padding: 15px 40px;
            margin: 10px;
            background: #333;
            border: 2px solid #555;
            border-radius: 4px;
            color: #fff;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }
        #gameOverlay button:hover {
            border-color: #ff6b35;
            background: #444;
        }

        /* Game UI */
        #gameUI { display: none; }
        #gameUI.active { display: flex; flex-direction: column; align-items: center; }

        #header {
            padding: 10px 20px;
            background: linear-gradient(180deg, #2d2d44 0%, #1a1a2e 100%);
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #ff6b35;
        }
        #header h1 {
            color: #ff6b35;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        #resources {
            display: flex;
            gap: 20px;
            font-size: 16px;
        }
        .resource {
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(0,0,0,0.3);
            padding: 5px 12px;
            border-radius: 4px;
        }
        .resource-icon { font-size: 18px; }
        #timer {
            background: rgba(255,107,53,0.2);
            border: 1px solid #ff6b35;
            padding: 5px 15px;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
        }
        #timer.warning { color: #f00; animation: pulse 1s infinite; }
        @keyframes pulse { 50% { opacity: 0.5; } }

        #gameContainer {
            display: flex;
            gap: 10px;
            padding: 10px;
        }
        #canvas {
            border: 3px solid #333;
            border-radius: 4px;
            cursor: crosshair;
        }
        #sidebar {
            width: 200px;
            background: #252538;
            border-radius: 4px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .panel {
            background: #1e1e30;
            border-radius: 4px;
            padding: 10px;
        }
        .panel h3 {
            color: #ff6b35;
            font-size: 12px;
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        #minimap {
            width: 180px;
            height: 180px;
            background: #111;
            border: 2px solid #444;
        }
        #selectionInfo {
            font-size: 12px;
            min-height: 60px;
        }
        #buildMenu {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
        }
        .build-btn {
            width: 50px;
            height: 50px;
            border: 2px solid #444;
            background: #333;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
        }
        .build-btn:hover {
            border-color: #ff6b35;
            background: #3d3d50;
        }
        .build-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .build-btn span {
            font-size: 8px;
            color: #aaa;
        }
        #footer {
            padding: 10px;
            font-size: 11px;
            color: #666;
        }
        .hotkey {
            color: #ff6b35;
            font-size: 10px;
        }
        #pauseBtn {
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 5px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }
        #pauseBtn:hover { border-color: #ff6b35; }
    </style>
</head>
<body>
    <!-- Main Menu -->
    <div id="mainMenu">
        <h1>XFIRE</h1>
        <div class="subtitle">Skirmish RTS</div>
        <div class="menu-panel">
            <h2>Game Settings</h2>
            <div class="setting-row">
                <label>Time Limit</label>
                <select id="timeLimit">
                    <option value="0">No Limit</option>
                    <option value="5">5 Minutes</option>
                    <option value="10" selected>10 Minutes</option>
                    <option value="15">15 Minutes</option>
                    <option value="20">20 Minutes</option>
                    <option value="30">30 Minutes</option>
                </select>
            </div>
            <div class="setting-row">
                <label>AI Difficulty</label>
                <select id="aiDifficulty">
                    <option value="easy">Easy</option>
                    <option value="normal" selected>Normal</option>
                    <option value="hard">Hard</option>
                </select>
            </div>
            <div class="setting-row">
                <label>Map Size</label>
                <select id="mapSize">
                    <option value="48">Small (48x48)</option>
                    <option value="64" selected>Medium (64x64)</option>
                    <option value="80">Large (80x80)</option>
                </select>
            </div>
            <div class="setting-row">
                <label>Starting Oil</label>
                <select id="startingOil">
                    <option value="500">500</option>
                    <option value="1000" selected>1000</option>
                    <option value="2000">2000</option>
                    <option value="5000">5000</option>
                </select>
            </div>
            <button id="startBtn">Start Game</button>
        </div>
    </div>

    <!-- Game Over Overlay -->
    <div id="gameOverlay" class="hidden">
        <h1 id="gameOverTitle">VICTORY</h1>
        <p id="gameOverText">You destroyed the enemy!</p>
        <div>
            <button id="playAgainBtn">Play Again</button>
            <button id="mainMenuBtn">Main Menu</button>
        </div>
    </div>

    <!-- Game UI -->
    <div id="gameUI">
        <div id="header">
            <h1>XFIRE</h1>
            <div id="resources">
                <div class="resource">
                    <span class="resource-icon">&#9981;</span>
                    <span>Oil: <strong id="oil">1000</strong></span>
                </div>
                <div class="resource">
                    <span class="resource-icon">&#9889;</span>
                    <span>Power: <strong id="power">100</strong></span>
                </div>
                <div id="timer">10:00</div>
                <button id="pauseBtn">Pause [P]</button>
            </div>
        </div>

        <div id="gameContainer">
            <canvas id="canvas" width="1000" height="600"></canvas>
            <div id="sidebar">
                <div class="panel">
                    <h3>Minimap</h3>
                    <canvas id="minimap" width="180" height="180"></canvas>
                </div>
                <div class="panel">
                    <h3>Selection</h3>
                    <div id="selectionInfo">No selection</div>
                </div>
                <div class="panel">
                    <h3>Build <span class="hotkey">[B]</span></h3>
                    <div id="buildMenu"></div>
                </div>
            </div>
        </div>

        <div id="footer">
            Controls: Left-click select | Right-click move/attack | Drag to box-select | WASD/Arrows scroll | 1-5 unit groups | P pause | ESC menu
        </div>
    </div>

    <script>
// ============================================
// XFIRE - Skirmish RTS Game Engine
// ============================================

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const minimapCanvas = document.getElementById('minimap');
const minimapCtx = minimapCanvas.getContext('2d');

// Game Constants
const TILE_WIDTH = 64;
const TILE_HEIGHT = 32;
let MAP_SIZE = 64;

// Game Settings
const settings = {
    timeLimit: 10,
    aiDifficulty: 'normal',
    mapSize: 64,
    startingOil: 1000
};

// Game State
const game = {
    state: 'menu', // menu, playing, paused, victory, defeat
    tick: 0,
    timeRemaining: 0,
    camera: { x: 0, y: 0 },
    mouse: { x: 0, y: 0, worldX: 0, worldY: 0 },
    selection: [],
    selectionBox: null,
    players: [
        { id: 0, color: '#4488ff', oil: 1000, power: 100, team: 'player' },
        { id: 1, color: '#ff4444', oil: 1000, power: 100, team: 'enemy' }
    ],
    units: [],
    buildings: [],
    projectiles: [],
    particles: [],
    map: [],
    fogOfWar: []
};

// Unit Types
const UNIT_TYPES = {
    infantry: {
        name: 'Infantry', icon: '&#9823;', cost: 100, hp: 50, speed: 1.5,
        range: 100, damage: 8, attackSpeed: 800, sight: 150, size: 8
    },
    tank: {
        name: 'Tank', icon: '&#9820;', cost: 300, hp: 200, speed: 1,
        range: 150, damage: 25, attackSpeed: 1500, sight: 180, size: 16
    },
    harvester: {
        name: 'Harvester', icon: '&#9819;', cost: 500, hp: 150, speed: 0.8,
        range: 0, damage: 0, attackSpeed: 0, sight: 120, size: 18, capacity: 500
    },
    artillery: {
        name: 'Artillery', icon: '&#9814;', cost: 400, hp: 80, speed: 0.6,
        range: 250, damage: 50, attackSpeed: 2500, sight: 200, size: 14
    },
    scout: {
        name: 'Scout', icon: '&#9816;', cost: 150, hp: 30, speed: 2.5,
        range: 80, damage: 5, attackSpeed: 500, sight: 250, size: 10
    }
};

// Building Types
const BUILDING_TYPES = {
    hq: {
        name: 'HQ', icon: '&#127984;', cost: 0, hp: 1000, size: 3,
        produces: ['infantry'], sight: 200
    },
    barracks: {
        name: 'Barracks', icon: '&#127976;', cost: 400, hp: 400, size: 2,
        produces: ['infantry', 'scout'], sight: 150
    },
    factory: {
        name: 'Factory', icon: '&#127981;', cost: 600, hp: 600, size: 3,
        produces: ['tank', 'harvester', 'artillery'], sight: 150
    },
    derrick: {
        name: 'Derrick', icon: '&#9981;', cost: 200, hp: 200, size: 1,
        produces: [], generates: 10, sight: 100
    },
    turret: {
        name: 'Turret', icon: '&#9876;', cost: 350, hp: 300, size: 1,
        produces: [], range: 180, damage: 20, attackSpeed: 1000, sight: 180
    },
    powerplant: {
        name: 'Power Plant', icon: '&#9889;', cost: 300, hp: 250, size: 2,
        produces: [], powerGen: 50, sight: 100
    }
};

// AI difficulty multipliers
const AI_DIFFICULTY = {
    easy: { oilMult: 0.5, attackThreshold: 8, buildDelay: 180 },
    normal: { oilMult: 1.0, attackThreshold: 5, buildDelay: 120 },
    hard: { oilMult: 1.5, attackThreshold: 3, buildDelay: 60 }
};

// ============================================
// MENU HANDLING
// ============================================

document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('playAgainBtn').addEventListener('click', startGame);
document.getElementById('mainMenuBtn').addEventListener('click', showMainMenu);
document.getElementById('pauseBtn').addEventListener('click', togglePause);

function showMainMenu() {
    game.state = 'menu';
    document.getElementById('mainMenu').classList.remove('hidden');
    document.getElementById('gameOverlay').classList.add('hidden');
    document.getElementById('gameUI').classList.remove('active');
}

function startGame() {
    // Read settings
    settings.timeLimit = parseInt(document.getElementById('timeLimit').value);
    settings.aiDifficulty = document.getElementById('aiDifficulty').value;
    settings.mapSize = parseInt(document.getElementById('mapSize').value);
    settings.startingOil = parseInt(document.getElementById('startingOil').value);

    MAP_SIZE = settings.mapSize;

    // Reset game state
    game.state = 'playing';
    game.tick = 0;
    game.timeRemaining = settings.timeLimit * 60 * 60; // Convert to ticks (60fps)
    game.units = [];
    game.buildings = [];
    game.projectiles = [];
    game.particles = [];
    game.selection = [];
    game.players[0].oil = settings.startingOil;
    game.players[1].oil = settings.startingOil;

    // Hide menu, show game
    document.getElementById('mainMenu').classList.add('hidden');
    document.getElementById('gameOverlay').classList.add('hidden');
    document.getElementById('gameUI').classList.add('active');

    // Initialize
    initGame();
}

function togglePause() {
    if (game.state === 'playing') {
        game.state = 'paused';
        document.getElementById('pauseBtn').textContent = 'Resume [P]';
    } else if (game.state === 'paused') {
        game.state = 'playing';
        document.getElementById('pauseBtn').textContent = 'Pause [P]';
    }
}

function showGameOver(victory) {
    game.state = victory ? 'victory' : 'defeat';
    const overlay = document.getElementById('gameOverlay');
    overlay.classList.remove('hidden', 'victory', 'defeat');
    overlay.classList.add(victory ? 'victory' : 'defeat');

    document.getElementById('gameOverTitle').textContent = victory ? 'VICTORY!' : 'DEFEAT';
    document.getElementById('gameOverText').textContent = victory
        ? 'You destroyed all enemy forces!'
        : 'Your forces have been eliminated!';
}

// ============================================
// MAP GENERATION
// ============================================

function generateMap() {
    game.map = [];
    game.fogOfWar = [];

    for (let y = 0; y < MAP_SIZE; y++) {
        game.map[y] = [];
        game.fogOfWar[y] = [];
        for (let x = 0; x < MAP_SIZE; x++) {
            game.map[y][x] = {
                type: 'grass',
                height: 0,
                oil: false
            };
            game.fogOfWar[y][x] = 0;
        }
    }

    // Add terrain features
    for (let y = 0; y < MAP_SIZE; y++) {
        for (let x = 0; x < MAP_SIZE; x++) {
            const noise = Math.sin(x * 0.1) * Math.cos(y * 0.1) +
                         Math.sin(x * 0.05 + 1) * Math.cos(y * 0.07) * 0.5;

            if (noise > 0.7) {
                game.map[y][x].type = 'rock';
                game.map[y][x].height = 1;
            } else if (noise < -0.6) {
                game.map[y][x].type = 'water';
                game.map[y][x].height = -1;
            } else if (noise > 0.3 && noise < 0.5) {
                game.map[y][x].type = 'sand';
            }
        }
    }

    // Add oil deposits - ensure some near each base
    const oilCount = Math.floor(MAP_SIZE / 8) + Math.floor(Math.random() * 5);

    // Oil near player base
    addOilDeposit(15, 15);
    addOilDeposit(18, 12);

    // Oil near enemy base
    addOilDeposit(MAP_SIZE - 16, MAP_SIZE - 16);
    addOilDeposit(MAP_SIZE - 19, MAP_SIZE - 13);

    // Random oil in middle
    for (let i = 0; i < oilCount; i++) {
        const x = 10 + Math.floor(Math.random() * (MAP_SIZE - 20));
        const y = 10 + Math.floor(Math.random() * (MAP_SIZE - 20));
        addOilDeposit(x, y);
    }
}

function addOilDeposit(x, y) {
    if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
        if (game.map[y][x].type === 'grass' || game.map[y][x].type === 'sand') {
            game.map[y][x].oil = true;
        }
    }
}

// ============================================
// COORDINATE CONVERSION (Isometric)
// ============================================

function worldToScreen(x, y) {
    const isoX = (x - y) * (TILE_WIDTH / 2);
    const isoY = (x + y) * (TILE_HEIGHT / 2);
    return {
        x: isoX - game.camera.x + canvas.width / 2,
        y: isoY - game.camera.y + canvas.height / 2
    };
}

function screenToWorld(sx, sy) {
    const x = sx + game.camera.x - canvas.width / 2;
    const y = sy + game.camera.y - canvas.height / 2;
    const worldX = (x / (TILE_WIDTH / 2) + y / (TILE_HEIGHT / 2)) / 2;
    const worldY = (y / (TILE_HEIGHT / 2) - x / (TILE_WIDTH / 2)) / 2;
    return { x: worldX, y: worldY };
}

// ============================================
// RENDERING
// ============================================

function render() {
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const startTile = screenToWorld(0, 0);
    const endTile = screenToWorld(canvas.width, canvas.height);

    const minX = Math.max(0, Math.floor(startTile.x) - 2);
    const maxX = Math.min(MAP_SIZE, Math.ceil(endTile.x) + 4);
    const minY = Math.max(0, Math.floor(startTile.y) - 2);
    const maxY = Math.min(MAP_SIZE, Math.ceil(endTile.y) + 4);

    // Draw tiles
    for (let y = minY; y < maxY; y++) {
        for (let x = minX; x < maxX; x++) {
            drawTile(x, y);
        }
    }

    // Draw buildings
    const sortedBuildings = [...game.buildings].sort((a, b) => a.y - b.y);
    for (const building of sortedBuildings) {
        drawBuilding(building);
    }

    // Draw units
    const sortedUnits = [...game.units].sort((a, b) => a.y - b.y);
    for (const unit of sortedUnits) {
        drawUnit(unit);
    }

    // Draw projectiles
    for (const proj of game.projectiles) {
        drawProjectile(proj);
    }

    // Draw particles
    for (const particle of game.particles) {
        drawParticle(particle);
    }

    // Draw selection box
    if (game.selectionBox) {
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(
            game.selectionBox.x1,
            game.selectionBox.y1,
            game.selectionBox.x2 - game.selectionBox.x1,
            game.selectionBox.y2 - game.selectionBox.y1
        );
        ctx.setLineDash([]);
    }

    // Draw pause overlay
    if (game.state === 'paused') {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = '48px Segoe UI';
        ctx.textAlign = 'center';
        ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
        ctx.font = '18px Segoe UI';
        ctx.fillText('Press P to resume', canvas.width / 2, canvas.height / 2 + 40);
    }

    renderMinimap();
}

function drawTile(tx, ty) {
    const tile = game.map[ty]?.[tx];
    if (!tile) return;

    const fog = game.fogOfWar[ty]?.[tx] ?? 0;
    const screen = worldToScreen(tx, ty);

    const colors = {
        grass: '#3d5c3d',
        sand: '#a08050',
        rock: '#606060',
        water: '#304060'
    };

    let color = colors[tile.type] || colors.grass;

    if (tile.height > 0) {
        color = shadeColor(color, 20);
    } else if (tile.height < 0) {
        color = shadeColor(color, -20);
    }

    ctx.beginPath();
    ctx.moveTo(screen.x, screen.y - TILE_HEIGHT / 2);
    ctx.lineTo(screen.x + TILE_WIDTH / 2, screen.y);
    ctx.lineTo(screen.x, screen.y + TILE_HEIGHT / 2);
    ctx.lineTo(screen.x - TILE_WIDTH / 2, screen.y);
    ctx.closePath();

    ctx.fillStyle = color;
    ctx.fill();

    ctx.strokeStyle = shadeColor(color, -15);
    ctx.lineWidth = 1;
    ctx.stroke();

    if (tile.oil && fog >= 1) {
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#111';
        ctx.beginPath();
        ctx.arc(screen.x, screen.y - 2, 5, 0, Math.PI * 2);
        ctx.fill();
    }

    if (fog === 0) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fill();
    } else if (fog === 1) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fill();
    }
}

function drawBuilding(building) {
    const type = BUILDING_TYPES[building.type];
    const screen = worldToScreen(building.x, building.y);
    const player = game.players[building.playerId];

    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.beginPath();
    ctx.ellipse(screen.x + 5, screen.y + 10, type.size * 15, type.size * 8, 0, 0, Math.PI * 2);
    ctx.fill();

    const size = type.size * 20;
    ctx.fillStyle = shadeColor(player.color, -30);
    ctx.fillRect(screen.x - size/2, screen.y - size, size, size);

    ctx.fillStyle = player.color;
    ctx.fillRect(screen.x - size/2, screen.y - size - 10, size, size);

    ctx.fillStyle = shadeColor(player.color, 30);
    ctx.fillRect(screen.x - size/2 + 4, screen.y - size - 6, size - 8, 4);

    const hpPercent = building.hp / type.hp;
    ctx.fillStyle = '#333';
    ctx.fillRect(screen.x - 20, screen.y - size - 20, 40, 4);
    ctx.fillStyle = hpPercent > 0.5 ? '#0f0' : hpPercent > 0.25 ? '#ff0' : '#f00';
    ctx.fillRect(screen.x - 20, screen.y - size - 20, 40 * hpPercent, 4);

    if (game.selection.includes(building)) {
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        ctx.strokeRect(screen.x - size/2 - 3, screen.y - size - 13, size + 6, size + 16);
    }

    if (building.producing) {
        const progress = building.produceProgress / building.produceTime;
        ctx.fillStyle = '#555';
        ctx.fillRect(screen.x - 15, screen.y + 5, 30, 3);
        ctx.fillStyle = '#0ff';
        ctx.fillRect(screen.x - 15, screen.y + 5, 30 * progress, 3);
    }
}

function drawUnit(unit) {
    const type = UNIT_TYPES[unit.type];
    const screen = worldToScreen(unit.x, unit.y);
    const player = game.players[unit.playerId];

    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
    ctx.beginPath();
    ctx.ellipse(screen.x + 3, screen.y + 3, type.size * 0.8, type.size * 0.4, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = player.color;
    ctx.beginPath();
    ctx.arc(screen.x, screen.y - type.size / 2, type.size, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = shadeColor(player.color, 40);
    ctx.beginPath();
    ctx.arc(screen.x - 2, screen.y - type.size / 2 - 2, type.size * 0.5, 0, Math.PI * 2);
    ctx.fill();

    if (unit.targetX !== undefined || unit.attackTarget) {
        const angle = unit.angle || 0;
        ctx.strokeStyle = shadeColor(player.color, -30);
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(screen.x, screen.y - type.size / 2);
        ctx.lineTo(
            screen.x + Math.cos(angle) * type.size * 1.2,
            screen.y - type.size / 2 + Math.sin(angle) * type.size * 1.2
        );
        ctx.stroke();
    }

    const hpPercent = unit.hp / type.hp;
    if (hpPercent < 1) {
        ctx.fillStyle = '#333';
        ctx.fillRect(screen.x - 12, screen.y - type.size - 10, 24, 3);
        ctx.fillStyle = hpPercent > 0.5 ? '#0f0' : hpPercent > 0.25 ? '#ff0' : '#f00';
        ctx.fillRect(screen.x - 12, screen.y - type.size - 10, 24 * hpPercent, 3);
    }

    if (game.selection.includes(unit)) {
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y - type.size / 2, type.size + 4, 0, Math.PI * 2);
        ctx.stroke();
    }

    if (unit.type === 'harvester' && unit.cargo > 0) {
        ctx.fillStyle = '#000';
        ctx.fillRect(screen.x - 10, screen.y + 5, 20, 4);
        ctx.fillStyle = '#fa0';
        ctx.fillRect(screen.x - 10, screen.y + 5, 20 * (unit.cargo / type.capacity), 4);
    }
}

function drawProjectile(proj) {
    const screen = worldToScreen(proj.x, proj.y);

    ctx.strokeStyle = '#ff8800';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(screen.x, screen.y);
    ctx.lineTo(screen.x - proj.vx * 3, screen.y - proj.vy * 3);
    ctx.stroke();

    ctx.fillStyle = '#ffff00';
    ctx.beginPath();
    ctx.arc(screen.x, screen.y, 3, 0, Math.PI * 2);
    ctx.fill();
}

function drawParticle(particle) {
    const screen = worldToScreen(particle.x, particle.y);
    ctx.globalAlpha = particle.life;
    ctx.fillStyle = particle.color;
    ctx.beginPath();
    ctx.arc(screen.x, screen.y - particle.z, particle.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
}

function renderMinimap() {
    minimapCtx.fillStyle = '#111';
    minimapCtx.fillRect(0, 0, 180, 180);

    const scale = 180 / MAP_SIZE;

    for (let y = 0; y < MAP_SIZE; y++) {
        for (let x = 0; x < MAP_SIZE; x++) {
            const tile = game.map[y][x];
            const fog = game.fogOfWar[y][x];

            if (fog === 0) continue;

            let color = '#3d5c3d';
            if (tile.type === 'water') color = '#304060';
            else if (tile.type === 'rock') color = '#606060';
            else if (tile.type === 'sand') color = '#a08050';

            if (fog === 1) color = shadeColor(color, -40);

            minimapCtx.fillStyle = color;
            minimapCtx.fillRect(x * scale, y * scale, scale + 1, scale + 1);

            if (tile.oil) {
                minimapCtx.fillStyle = '#000';
                minimapCtx.fillRect(x * scale, y * scale, scale, scale);
            }
        }
    }

    for (const b of game.buildings) {
        minimapCtx.fillStyle = game.players[b.playerId].color;
        minimapCtx.fillRect(b.x * scale - 2, b.y * scale - 2, 4, 4);
    }

    for (const u of game.units) {
        minimapCtx.fillStyle = game.players[u.playerId].color;
        minimapCtx.fillRect(u.x * scale - 1, u.y * scale - 1, 2, 2);
    }

    const viewStart = screenToWorld(0, 0);
    const viewEnd = screenToWorld(canvas.width, canvas.height);
    minimapCtx.strokeStyle = '#fff';
    minimapCtx.lineWidth = 1;
    minimapCtx.strokeRect(
        viewStart.x * scale,
        viewStart.y * scale,
        (viewEnd.x - viewStart.x) * scale,
        (viewEnd.y - viewStart.y) * scale
    );
}

// ============================================
// GAME LOGIC
// ============================================

function update(dt) {
    if (game.state !== 'playing') return;

    game.tick++;

    // Timer
    if (settings.timeLimit > 0) {
        game.timeRemaining--;
        if (game.timeRemaining <= 0) {
            // Time's up - determine winner by remaining units/buildings
            const playerScore = game.units.filter(u => u.playerId === 0).length +
                               game.buildings.filter(b => b.playerId === 0).length * 2;
            const enemyScore = game.units.filter(u => u.playerId === 1).length +
                              game.buildings.filter(b => b.playerId === 1).length * 2;
            showGameOver(playerScore >= enemyScore);
            return;
        }
    }

    // Check win/lose conditions
    checkVictoryConditions();

    updateUnits(dt);
    updateBuildings(dt);
    updateProjectiles(dt);
    updateParticles(dt);
    updateFogOfWar();
    updateAI();
    updateResources();
    updateUI();
}

function checkVictoryConditions() {
    const playerUnits = game.units.filter(u => u.playerId === 0);
    const playerBuildings = game.buildings.filter(b => b.playerId === 0);
    const enemyUnits = game.units.filter(u => u.playerId === 1);
    const enemyBuildings = game.buildings.filter(b => b.playerId === 1);

    // Defeat: player has nothing left
    if (playerUnits.length === 0 && playerBuildings.length === 0) {
        showGameOver(false);
        return;
    }

    // Victory: enemy has nothing left
    if (enemyUnits.length === 0 && enemyBuildings.length === 0) {
        showGameOver(true);
        return;
    }
}

function updateUnits(dt) {
    for (let i = game.units.length - 1; i >= 0; i--) {
        const unit = game.units[i];
        const type = UNIT_TYPES[unit.type];

        if (unit.hp <= 0) {
            createExplosion(unit.x, unit.y);
            game.units.splice(i, 1);
            game.selection = game.selection.filter(s => s !== unit);
            continue;
        }

        if (unit.type === 'harvester') {
            updateHarvester(unit, type);
            continue;
        }

        if (unit.attackTarget) {
            const target = unit.attackTarget;
            if (target.hp <= 0) {
                unit.attackTarget = null;
            } else {
                const dx = target.x - unit.x;
                const dy = target.y - unit.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                unit.angle = Math.atan2(dy, dx);

                if (dist > type.range) {
                    unit.x += (dx / dist) * type.speed * dt * 60;
                    unit.y += (dy / dist) * type.speed * dt * 60;
                } else {
                    if (game.tick - unit.lastAttack > type.attackSpeed / 16) {
                        fireProjectile(unit, target);
                        unit.lastAttack = game.tick;
                    }
                }
            }
        } else if (unit.targetX !== undefined) {
            const dx = unit.targetX - unit.x;
            const dy = unit.targetY - unit.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 0.5) {
                unit.angle = Math.atan2(dy, dx);
                const speed = type.speed * dt * 60;
                unit.x += (dx / dist) * speed;
                unit.y += (dy / dist) * speed;

                for (const other of game.units) {
                    if (other === unit) continue;
                    const odx = unit.x - other.x;
                    const ody = unit.y - other.y;
                    const odist = Math.sqrt(odx * odx + ody * ody);
                    if (odist < 1 && odist > 0) {
                        unit.x += (odx / odist) * 0.3;
                        unit.y += (ody / odist) * 0.3;
                    }
                }
            } else {
                unit.targetX = undefined;
                unit.targetY = undefined;
            }
        }

        // Auto-attack
        if (!unit.attackTarget && type.damage > 0) {
            const enemies = [...game.units.filter(u => u.playerId !== unit.playerId),
                            ...game.buildings.filter(b => b.playerId !== unit.playerId)];
            for (const enemy of enemies) {
                const dx = enemy.x - unit.x;
                const dy = enemy.y - unit.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < type.sight) {
                    unit.attackTarget = enemy;
                    break;
                }
            }
        }

        unit.x = Math.max(0, Math.min(MAP_SIZE - 1, unit.x));
        unit.y = Math.max(0, Math.min(MAP_SIZE - 1, unit.y));
    }
}

function updateHarvester(unit, type) {
    const player = game.players[unit.playerId];
    const hq = game.buildings.find(b => b.playerId === unit.playerId && b.type === 'hq');

    if (unit.cargo >= type.capacity || (unit.returning && unit.cargo > 0)) {
        unit.returning = true;
        if (hq) {
            const dx = hq.x - unit.x;
            const dy = hq.y - unit.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 2) {
                unit.x += (dx / dist) * type.speed * 0.016 * 60;
                unit.y += (dy / dist) * type.speed * 0.016 * 60;
                unit.angle = Math.atan2(dy, dx);
            } else {
                player.oil += unit.cargo;
                unit.cargo = 0;
                unit.returning = false;
            }
        }
    } else {
        let nearestOil = null;
        let nearestDist = Infinity;

        for (let y = 0; y < MAP_SIZE; y++) {
            for (let x = 0; x < MAP_SIZE; x++) {
                if (game.map[y][x].oil) {
                    const hasDerrick = game.buildings.some(b =>
                        b.type === 'derrick' && Math.abs(b.x - x) < 1 && Math.abs(b.y - y) < 1
                    );
                    if (hasDerrick) continue;

                    const dx = x - unit.x;
                    const dy = y - unit.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestOil = { x, y };
                    }
                }
            }
        }

        if (nearestOil) {
            if (nearestDist > 1) {
                const dx = nearestOil.x - unit.x;
                const dy = nearestOil.y - unit.y;
                unit.x += (dx / nearestDist) * type.speed * 0.016 * 60;
                unit.y += (dy / nearestDist) * type.speed * 0.016 * 60;
                unit.angle = Math.atan2(dy, dx);
            } else {
                unit.cargo = Math.min(type.capacity, unit.cargo + 2);
            }
        } else if (unit.cargo > 0) {
            unit.returning = true;
        }
    }
}

function updateBuildings(dt) {
    for (let i = game.buildings.length - 1; i >= 0; i--) {
        const building = game.buildings[i];
        const type = BUILDING_TYPES[building.type];

        if (building.hp <= 0) {
            createExplosion(building.x, building.y, true);
            game.buildings.splice(i, 1);
            game.selection = game.selection.filter(s => s !== building);
            continue;
        }

        // Turret attack
        if (type.damage) {
            let nearestEnemy = null;
            let nearestDist = Infinity;

            const enemies = [...game.units.filter(u => u.playerId !== building.playerId),
                            ...game.buildings.filter(b => b.playerId !== building.playerId)];

            for (const enemy of enemies) {
                const dx = enemy.x - building.x;
                const dy = enemy.y - building.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < type.range && dist < nearestDist) {
                    nearestDist = dist;
                    nearestEnemy = enemy;
                }
            }

            if (nearestEnemy && game.tick - (building.lastAttack || 0) > type.attackSpeed / 16) {
                fireProjectile(building, nearestEnemy, type.damage);
                building.lastAttack = game.tick;
            }
        }

        if (building.producing) {
            building.produceProgress++;
            if (building.produceProgress >= building.produceTime) {
                spawnUnit(building.producing, building.playerId, building.x + 2, building.y + 2);
                building.producing = null;
                building.produceProgress = 0;
            }
        }
    }
}

function updateProjectiles(dt) {
    for (let i = game.projectiles.length - 1; i >= 0; i--) {
        const proj = game.projectiles[i];

        proj.x += proj.vx;
        proj.y += proj.vy;
        proj.life--;

        const dx = proj.targetX - proj.x;
        const dy = proj.targetY - proj.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 1 || proj.life <= 0) {
            if (proj.target && proj.target.hp > 0) {
                proj.target.hp -= proj.damage;
                createImpact(proj.x, proj.y);
            }
            game.projectiles.splice(i, 1);
        }
    }
}

function updateParticles(dt) {
    for (let i = game.particles.length - 1; i >= 0; i--) {
        const p = game.particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.z += p.vz;
        p.vz -= 0.1;
        p.life -= 0.02;

        if (p.life <= 0 || p.z < 0) {
            game.particles.splice(i, 1);
        }
    }
}

function updateFogOfWar() {
    for (let y = 0; y < MAP_SIZE; y++) {
        for (let x = 0; x < MAP_SIZE; x++) {
            if (game.fogOfWar[y][x] === 2) {
                game.fogOfWar[y][x] = 1;
            }
        }
    }

    const revealers = [
        ...game.units.filter(u => u.playerId === 0),
        ...game.buildings.filter(b => b.playerId === 0)
    ];

    for (const entity of revealers) {
        const type = UNIT_TYPES[entity.type] || BUILDING_TYPES[entity.type];
        const sight = type.sight / TILE_WIDTH * 2;

        for (let dy = -sight; dy <= sight; dy++) {
            for (let dx = -sight; dx <= sight; dx++) {
                if (dx * dx + dy * dy <= sight * sight) {
                    const tx = Math.floor(entity.x + dx);
                    const ty = Math.floor(entity.y + dy);
                    if (tx >= 0 && tx < MAP_SIZE && ty >= 0 && ty < MAP_SIZE) {
                        game.fogOfWar[ty][tx] = 2;
                    }
                }
            }
        }
    }
}

function updateAI() {
    const difficulty = AI_DIFFICULTY[settings.aiDifficulty];
    if (game.tick % difficulty.buildDelay !== 0) return;

    const ai = game.players[1];
    const aiUnits = game.units.filter(u => u.playerId === 1);
    const aiBuildings = game.buildings.filter(b => b.playerId === 1);
    const playerUnits = game.units.filter(u => u.playerId === 0);
    const playerBuildings = game.buildings.filter(b => b.playerId === 0);

    const aiHQ = aiBuildings.find(b => b.type === 'hq');
    const aiBarracks = aiBuildings.filter(b => b.type === 'barracks');
    const aiFactory = aiBuildings.filter(b => b.type === 'factory');
    const aiHarvesters = aiUnits.filter(u => u.type === 'harvester');

    // Build harvester if none
    if (aiHarvesters.length === 0 && aiFactory.length > 0) {
        const factory = aiFactory[0];
        if (!factory.producing && ai.oil >= 500) {
            startProduction(factory, 'harvester');
            ai.oil -= 500;
        }
    }

    // Build barracks
    if (aiHQ && ai.oil >= 400 && aiBarracks.length < 2) {
        const pos = findBuildPosition(aiHQ.x, aiHQ.y, 1);
        if (pos) {
            createBuilding('barracks', 1, pos.x, pos.y);
            ai.oil -= 400;
        }
    }

    // Build factory
    if (aiHQ && ai.oil >= 600 && aiFactory.length < 1 && aiBarracks.length > 0) {
        const pos = findBuildPosition(aiHQ.x, aiHQ.y, 1);
        if (pos) {
            createBuilding('factory', 1, pos.x, pos.y);
            ai.oil -= 600;
        }
    }

    // Produce units
    for (const barracks of aiBarracks) {
        if (!barracks.producing && ai.oil >= 100) {
            startProduction(barracks, 'infantry');
            ai.oil -= 100;
        }
    }

    for (const factory of aiFactory) {
        if (!factory.producing && ai.oil >= 300 && aiHarvesters.length > 0) {
            startProduction(factory, 'tank');
            ai.oil -= 300;
        }
    }

    // Attack when enough units
    const combatUnits = aiUnits.filter(u => u.type !== 'harvester');
    if (combatUnits.length >= difficulty.attackThreshold) {
        const target = playerBuildings[0] || playerUnits[0];
        if (target) {
            for (const unit of combatUnits) {
                if (!unit.attackTarget) {
                    unit.attackTarget = target;
                }
            }
        }
    }

    // AI gets oil bonus based on difficulty
    ai.oil += 10 * difficulty.oilMult;
}

function updateResources() {
    for (const building of game.buildings) {
        if (building.type === 'derrick') {
            const type = BUILDING_TYPES.derrick;
            game.players[building.playerId].oil += type.generates / 60;
        }
    }
}

function updateUI() {
    document.getElementById('oil').textContent = Math.floor(game.players[0].oil);
    document.getElementById('power').textContent = Math.floor(game.players[0].power);

    // Timer
    if (settings.timeLimit > 0) {
        const seconds = Math.max(0, Math.floor(game.timeRemaining / 60));
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        const timerEl = document.getElementById('timer');
        timerEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
        timerEl.classList.toggle('warning', seconds < 60);
    } else {
        document.getElementById('timer').textContent = '--:--';
    }

    // Selection info
    const infoEl = document.getElementById('selectionInfo');
    if (game.selection.length === 0) {
        infoEl.innerHTML = 'No selection';
    } else if (game.selection.length === 1) {
        const sel = game.selection[0];
        const type = UNIT_TYPES[sel.type] || BUILDING_TYPES[sel.type];
        infoEl.innerHTML = `
            <strong>${type.name}</strong><br>
            HP: ${Math.floor(sel.hp)}/${type.hp}<br>
            ${sel.cargo !== undefined ? `Cargo: ${Math.floor(sel.cargo)}/${type.capacity}` : ''}
            ${sel.producing ? `Building: ${sel.producing}` : ''}
        `;
    } else {
        infoEl.innerHTML = `${game.selection.length} units selected`;
    }

    updateBuildMenu();
}

function updateBuildMenu() {
    const menu = document.getElementById('buildMenu');
    const player = game.players[0];

    const selectedBuilding = game.selection.find(s => BUILDING_TYPES[s.type]);

    if (selectedBuilding && selectedBuilding.playerId === 0) {
        const type = BUILDING_TYPES[selectedBuilding.type];
        menu.innerHTML = '';

        for (const unitType of type.produces) {
            const uType = UNIT_TYPES[unitType];
            const btn = document.createElement('button');
            btn.className = 'build-btn';
            btn.innerHTML = `${uType.icon}<span>${uType.cost}</span>`;
            btn.title = `${uType.name} - ${uType.cost} oil`;
            btn.disabled = player.oil < uType.cost || selectedBuilding.producing;
            btn.onclick = () => {
                if (player.oil >= uType.cost && !selectedBuilding.producing) {
                    player.oil -= uType.cost;
                    startProduction(selectedBuilding, unitType);
                }
            };
            menu.appendChild(btn);
        }
    } else {
        menu.innerHTML = '';
        const buildable = ['barracks', 'factory', 'derrick', 'turret', 'powerplant'];

        for (const bType of buildable) {
            const type = BUILDING_TYPES[bType];
            const btn = document.createElement('button');
            btn.className = 'build-btn';
            btn.innerHTML = `${type.icon}<span>${type.cost}</span>`;
            btn.title = `${type.name} - ${type.cost} oil`;
            btn.disabled = player.oil < type.cost;
            btn.onclick = () => {
                if (player.oil >= type.cost) {
                    game.placingBuilding = bType;
                }
            };
            menu.appendChild(btn);
        }
    }
}

// ============================================
// HELPER FUNCTIONS
// ============================================

function spawnUnit(type, playerId, x, y) {
    const unitType = UNIT_TYPES[type];
    game.units.push({
        type,
        playerId,
        x, y,
        hp: unitType.hp,
        angle: 0,
        lastAttack: 0,
        cargo: 0
    });
}

function createBuilding(type, playerId, x, y) {
    const bType = BUILDING_TYPES[type];
    game.buildings.push({
        type,
        playerId,
        x, y,
        hp: bType.hp,
        producing: null,
        produceProgress: 0,
        produceTime: 0
    });
}

function startProduction(building, unitType) {
    building.producing = unitType;
    building.produceProgress = 0;
    building.produceTime = 180;
}

function fireProjectile(source, target, customDamage) {
    const type = UNIT_TYPES[source.type] || BUILDING_TYPES[source.type];
    const damage = customDamage || type.damage;

    const dx = target.x - source.x;
    const dy = target.y - source.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const speed = 0.3;

    game.projectiles.push({
        x: source.x,
        y: source.y,
        vx: (dx / dist) * speed,
        vy: (dy / dist) * speed,
        targetX: target.x,
        targetY: target.y,
        target,
        damage,
        life: 100
    });
}

function createExplosion(x, y, big = false) {
    const count = big ? 20 : 10;
    for (let i = 0; i < count; i++) {
        game.particles.push({
            x, y, z: 0,
            vx: (Math.random() - 0.5) * 0.3,
            vy: (Math.random() - 0.5) * 0.3,
            vz: Math.random() * 0.5 + 0.2,
            color: Math.random() > 0.5 ? '#ff6600' : '#ffaa00',
            size: Math.random() * 4 + 2,
            life: 1
        });
    }
}

function createImpact(x, y) {
    for (let i = 0; i < 3; i++) {
        game.particles.push({
            x, y, z: 0,
            vx: (Math.random() - 0.5) * 0.1,
            vy: (Math.random() - 0.5) * 0.1,
            vz: Math.random() * 0.2,
            color: '#888',
            size: 2,
            life: 0.5
        });
    }
}

function findBuildPosition(nearX, nearY, playerId) {
    for (let r = 3; r < 10; r++) {
        for (let angle = 0; angle < Math.PI * 2; angle += 0.5) {
            const x = Math.floor(nearX + Math.cos(angle) * r);
            const y = Math.floor(nearY + Math.sin(angle) * r);

            if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) continue;
            if (game.map[y][x].type === 'water' || game.map[y][x].type === 'rock') continue;

            const blocked = game.buildings.some(b => {
                const size = BUILDING_TYPES[b.type].size;
                return Math.abs(b.x - x) < size + 1 && Math.abs(b.y - y) < size + 1;
            });

            if (!blocked) return { x, y };
        }
    }
    return null;
}

function shadeColor(color, percent) {
    const num = parseInt(color.replace('#', ''), 16);
    const amt = Math.round(2.55 * percent);
    const R = Math.max(0, Math.min(255, (num >> 16) + amt));
    const G = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amt));
    const B = Math.max(0, Math.min(255, (num & 0x0000FF) + amt));
    return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
}

// ============================================
// INPUT HANDLING
// ============================================

const keys = {};

canvas.addEventListener('mousedown', (e) => {
    if (game.state !== 'playing') return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (e.button === 0) {
        if (game.placingBuilding) {
            const world = screenToWorld(x, y);
            const tx = Math.floor(world.x);
            const ty = Math.floor(world.y);
            const type = BUILDING_TYPES[game.placingBuilding];

            if (game.players[0].oil >= type.cost) {
                if (game.placingBuilding === 'derrick') {
                    if (!game.map[ty]?.[tx]?.oil) {
                        game.placingBuilding = null;
                        return;
                    }
                }

                createBuilding(game.placingBuilding, 0, tx, ty);
                game.players[0].oil -= type.cost;
            }
            game.placingBuilding = null;
        } else {
            game.selectionBox = { x1: x, y1: y, x2: x, y2: y };
        }
    } else if (e.button === 2) {
        const world = screenToWorld(x, y);

        const enemy = game.units.find(u => {
            if (u.playerId === 0) return false;
            const screen = worldToScreen(u.x, u.y);
            const dx = screen.x - x;
            const dy = screen.y - y;
            return Math.sqrt(dx * dx + dy * dy) < 20;
        }) || game.buildings.find(b => {
            if (b.playerId === 0) return false;
            const screen = worldToScreen(b.x, b.y);
            const dx = screen.x - x;
            const dy = screen.y - y;
            return Math.sqrt(dx * dx + dy * dy) < 30;
        });

        for (const sel of game.selection) {
            if (UNIT_TYPES[sel.type] && sel.playerId === 0) {
                if (enemy) {
                    sel.attackTarget = enemy;
                    sel.targetX = undefined;
                    sel.targetY = undefined;
                } else {
                    sel.targetX = world.x;
                    sel.targetY = world.y;
                    sel.attackTarget = null;
                }
            }
        }
    }
});

canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    game.mouse.x = e.clientX - rect.left;
    game.mouse.y = e.clientY - rect.top;

    const world = screenToWorld(game.mouse.x, game.mouse.y);
    game.mouse.worldX = world.x;
    game.mouse.worldY = world.y;

    if (game.selectionBox) {
        game.selectionBox.x2 = game.mouse.x;
        game.selectionBox.y2 = game.mouse.y;
    }
});

canvas.addEventListener('mouseup', (e) => {
    if (e.button === 0 && game.selectionBox) {
        const box = game.selectionBox;
        const minX = Math.min(box.x1, box.x2);
        const maxX = Math.max(box.x1, box.x2);
        const minY = Math.min(box.y1, box.y2);
        const maxY = Math.max(box.y1, box.y2);

        if (!keys['Shift']) {
            game.selection = [];
        }

        if (maxX - minX < 5 && maxY - minY < 5) {
            const clicked = [...game.units, ...game.buildings].find(entity => {
                const screen = worldToScreen(entity.x, entity.y);
                const dx = screen.x - game.mouse.x;
                const dy = screen.y - game.mouse.y;
                return Math.sqrt(dx * dx + dy * dy) < 20;
            });

            if (clicked && clicked.playerId === 0) {
                game.selection = [clicked];
            }
        } else {
            for (const unit of game.units) {
                if (unit.playerId !== 0) continue;
                const screen = worldToScreen(unit.x, unit.y);
                if (screen.x >= minX && screen.x <= maxX &&
                    screen.y >= minY && screen.y <= maxY) {
                    game.selection.push(unit);
                }
            }
        }

        game.selectionBox = null;
    }
});

canvas.addEventListener('contextmenu', (e) => e.preventDefault());

minimapCanvas.addEventListener('click', (e) => {
    if (game.state !== 'playing' && game.state !== 'paused') return;

    const rect = minimapCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const scale = MAP_SIZE / 180;
    game.camera.x = x * scale * TILE_WIDTH / 2;
    game.camera.y = y * scale * TILE_HEIGHT;
});

document.addEventListener('keydown', (e) => {
    keys[e.key] = true;

    if (e.key === 'p' || e.key === 'P') {
        togglePause();
    }

    if (e.key === 'Escape') {
        if (game.state === 'playing' || game.state === 'paused') {
            game.placingBuilding = null;
            game.selection = [];
        }
    }

    if (game.state !== 'playing') return;

    if (e.key >= '1' && e.key <= '5') {
        if (e.ctrlKey) {
            game[`group${e.key}`] = [...game.selection];
        } else {
            game.selection = game[`group${e.key}`] || [];
        }
    }

    if (e.key === 's' || e.key === 'S') {
        for (const sel of game.selection) {
            sel.targetX = undefined;
            sel.targetY = undefined;
            sel.attackTarget = null;
        }
    }
});

document.addEventListener('keyup', (e) => {
    keys[e.key] = false;
});

function updateCamera() {
    if (game.state !== 'playing' && game.state !== 'paused') return;

    const speed = 10;
    if (keys['ArrowUp'] || keys['w'] || keys['W']) game.camera.y -= speed;
    if (keys['ArrowDown']) game.camera.y += speed;
    if (keys['ArrowLeft'] || keys['a'] || keys['A']) game.camera.x -= speed;
    if (keys['ArrowRight'] || keys['d'] || keys['D']) game.camera.x += speed;
}

// ============================================
// GAME INITIALIZATION
// ============================================

function initGame() {
    generateMap();

    // Player base: HQ + Harvester
    createBuilding('hq', 0, 10, 10);
    spawnUnit('harvester', 0, 12, 12);

    // Enemy base: HQ + Harvester
    createBuilding('hq', 1, MAP_SIZE - 12, MAP_SIZE - 12);
    spawnUnit('harvester', 1, MAP_SIZE - 14, MAP_SIZE - 14);

    // Center camera on player base
    const playerHQ = game.buildings.find(b => b.playerId === 0 && b.type === 'hq');
    if (playerHQ) {
        game.camera.x = playerHQ.x * TILE_WIDTH / 2;
        game.camera.y = playerHQ.y * TILE_HEIGHT;
    }
}

// ============================================
// GAME LOOP
// ============================================

let lastTime = 0;

function gameLoop(timestamp) {
    const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
    lastTime = timestamp;

    updateCamera();

    if (game.state === 'playing') {
        update(dt);
    }

    if (game.state !== 'menu') {
        render();
    }

    requestAnimationFrame(gameLoop);
}

// Start loop
requestAnimationFrame(gameLoop);

console.log('XFire RTS Engine loaded!');
    </script>
</body>
</html>
